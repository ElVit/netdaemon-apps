using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Reactive.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using NetDaemon.AppModel;
using NetDaemon.Extensions.Scheduler;
using NetDaemon.HassModel.Common;

// Use unique namespaces for your apps if you going to share with others to avoid
// conflicting names
namespace NotifyOnUpdate;

public class NotifyOnHassUpdateConfig
{
  // This property will be automapped with 'update_time_in_sec' config
  // Using autogenerated entity classes in HassModel
  public double? UpdateTimeInSec { get; set; }
  public string? Title { get; set; }
}

/// <summary>
/// Notifies of new updates in HACS
/// </summary>
[NetDaemonApp]
public class NotifyOnHassUpdate
{
  private HttpClient mHttpClient = new HttpClient();
  private readonly ILogger<NotifyOnHassUpdate> mLogger;

  public NotifyOnHassUpdate(IHaContext ha, INetDaemonScheduler scheduler,
                            IAppConfig<NotifyOnHassUpdateConfig> config,
                            ILogger<NotifyOnHassUpdate> logger)
  {
    mLogger = logger;
    mLogger.LogInformation("NotifyOnHAUpdate started");

    scheduler.RunEvery(TimeSpan.FromSeconds(config.Value.UpdateTimeInSec ?? 30), async () =>
    {
      var serviceDataTitle = config.Value.Title ?? "Updates pending in Home Assistant";
      var serviceDataMessage = String.Empty;
      var serviceDataId = "updates_ha";

      serviceDataMessage = await GetVersionByCurl(serviceDataMessage, "Core");
      serviceDataMessage = await GetVersionByCurl(serviceDataMessage, "OS");
      serviceDataMessage = await GetVersionByCurl(serviceDataMessage, "Supervisor");

      if (!String.IsNullOrEmpty(serviceDataMessage))
      {
        ha.CallService("persistent_notification", "create", data: new
        {
          title = serviceDataTitle,
          message = serviceDataMessage,
          notification_id = serviceDataId
        });
      }
      else
      {
        ha.CallService("persistent_notification", "dismiss", data: new
        {
          notification_id = serviceDataId
        });
      }
    });
  }

  private async Task<string> GetVersionByCurl(string message, string versionType)
  {
    var newMessage = message;
    var supervisorToken = Environment.GetEnvironmentVariable("SUPERVISOR_TOKEN") ?? "(none)";

    using (var request = new HttpRequestMessage(HttpMethod.Get, $"http://supervisor/{versionType.ToLower()}/info"))
    {
      request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", supervisorToken);
      var response = await mHttpClient.SendAsync(request);
      var responseContent = await response.Content.ReadAsStringAsync();
      var curl = JsonSerializer.Deserialize<CurlContent>(responseContent);
      var curlData = curl?.data;

      var update_available = curlData?.update_available ?? false;
      if(update_available)
      {
        mLogger.LogInformation("New Home Assistant Update is available");
        if (String.IsNullOrEmpty(newMessage))
        {
          newMessage = "[Home Assistant](/config/dashboard)\n\n";
        }
        newMessage += $"* **{versionType}** {curlData?.version} \uD83E\uDC16 {curlData?.version_latest}\n";;
      }

      if (curlData?.addons != null && curlData.addons.Where(x => x.update_available != null).Any(x => x.update_available == true))
      {
        mLogger.LogInformation("New Addon Update is available");
        newMessage += $"\n\n[Add-ons](/config/dashboard)\n\n";;
        foreach(var addon in curlData.addons)
        {
          var addon_update_available = curlData?.update_available ?? false;
          if(addon_update_available)
          {
            newMessage += $"* [**{addon?.name}**](/hassio/addon/{addon?.slug}/info) {addon?.version} \uD83E\uDC16 {addon?.version_latest}\n";
          }
        }
      }
    }

    return newMessage;
  }
}

internal class CurlContent
{
  public string? result { get; set; }
  public CurlData? data { get; set; }
}

internal class CurlData
{
  public string? version { get; set; }
  public string? version_latest { get; set; }
  public bool? update_available { get; set; }
  public IEnumerable<CurlAddon>? addons { get; set; }
}

internal class CurlAddon
{
  public string? name { get; set; }
  public string? slug { get; set; }
  public string? version { get; set; }
  public string? version_latest { get; set; }
  public bool? update_available { get; set; }
}
